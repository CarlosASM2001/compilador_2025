package ve.edu.unet;

import java_cup.runtime.*;
import ve.edu.unet.nodosAST.*;
import java.io.InputStreamReader;


parser code {:

/***********
SymbolFactory es una nueva caracteristica que ha sido añadida a las version 11a de cup, la cual facilita la implementacion de clases Symbol personalizadas
, esto debido a que dicha clase no provee mucha información de contexto que podria ser util para el analisis semantico o ayudar en la construccion del AST
Mas informacion en: http//4thmouse.com/index.php/2007/02/15/using-custom-symbols-in-cup/
***********/
	public static void main(String args[]) throws Exception {
		SymbolFactory sf = new DefaultSymbolFactory();
		parser parser_obj;
		if (args.length==0) 
			parser_obj=new parser(new Lexico(new InputStreamReader(System.in),sf),sf);
		else
			parser_obj=new parser(new Lexico(new InputStreamReader(new java.io.FileInputStream(args[0])),sf),sf);

		parser_obj.parse();
		NodoBase root=parser_obj.action_obj.getASTroot();
		System.out.println();
		System.out.println("IMPRESION DEL AST GENERADO");
		System.out.println();
        Util.imprimirAST(root);
		TablaSimbolos ts = new TablaSimbolos();
		ts.cargarTabla(root);
		ts.ImprimirClaves();
		Generador.setTablaSimbolos(ts);
		String outName = "../ejemplo_generado/" + (args.length>0 ? new java.io.File(args[0]).getName().replaceAll("\\.[^.]*$", "") : "salida") + ".tm";
		Generador.setOutputFilename(outName);
		Generador.generarCodigoObjeto(root);
	}

:}

action code {:
	private boolean debug=true;
	private NodoBase ast=null;
	private int lineanum=0;
	
	//Debe ser llamada solo despues de un parse(), en caso contrario retornara null siempre;
	public NodoBase getASTroot(){
		return ast;
	}
	
:}

/* Simbolos Terminales */

terminal IF;
terminal THEN;
terminal ELSE;
terminal BEGIN;
terminal END;
terminal REPEAT;
terminal UNTIL;
terminal READ;
terminal WRITE;
terminal FOR;
terminal TO;
terminal STEP;
terminal LBRACKET;
terminal RBRACKET;
terminal COMMA;
terminal MOD;
terminal AND;
terminal OR;
terminal NOT;
terminal GT;
terminal GE;
terminal LE;
terminal NE;
terminal POW;
terminal GLOBAL;
terminal VAR;
terminal ARRAY;
terminal FUNCTION;
terminal RETURN;
terminal CALL;
terminal COLON;
terminal String ID;
terminal String NUM;
terminal ASSIGN;
terminal EQ;
terminal LT;
terminal PLUS;
terminal MINUS;
terminal TIMES;
terminal OVER;
terminal LPAREN;
terminal RPAREN;
terminal SEMI;

/* Simbolos No Terminales */
non terminal program;
non terminal NodoBase preamble;
non terminal NodoBase pre_item;
non terminal NodoBase stmt_seq;
non terminal NodoBase stmt;
non terminal NodoBase if_stmt;
non terminal NodoBase repeat_stmt;
non terminal NodoBase assign_stmt;
non terminal NodoBase read_stmt;
non terminal NodoBase write_stmt;
non terminal NodoBase for_stmt;
non terminal NodoBase decl_stmt;
non terminal NodoBase return_stmt;
non terminal NodoBase func_decl;
non terminal NodoBase exp;
non terminal NodoBase logic_exp;
non terminal NodoBase simple_exp;
non terminal NodoBase term;
non terminal NodoBase factor;

/* Precedencia de operadores */
precedence right POW;
precedence left OR;
precedence left AND;
precedence left EQ, NE, LT, LE, GT, GE;
precedence left PLUS, MINUS;
precedence left TIMES, OVER, MOD;


/* REGLAS GRAMATICALES */
program     ::= preamble:p BEGIN stmt_seq:s END
				{: if(debug) System.out.println("\t regla 1"); 
					if(p!=null){
						NodoBase hijoActual = p;
						while(hijoActual.TieneHermano()){
							hijoActual = hijoActual.getHermanoDerecha();
						}
						hijoActual.setHermanoDerecha(s);
						ast = p;
					}else{
						ast = s;
					}
					:}
		| BEGIN stmt_seq:s END	{: if(debug) System.out.println("\t regla 1b");
					ast = s; :}
		;

preamble   ::= pre_item:item	{: RESULT = item; :}
		| preamble:ini pre_item:item
				{: if(debug) System.out.println("\t regla 13a");
					NodoBase hijoActual = ini;
					if(hijoActual !=null){
						while(hijoActual.TieneHermano()){
							hijoActual = hijoActual.getHermanoDerecha();
						}
						hijoActual.setHermanoDerecha(item);
						RESULT=ini;
					}else{
						RESULT=item;
					}
					:}
		;

pre_item   ::= GLOBAL ID:variable SEMI
				{: if(debug) System.out.println("\t regla 14a");
					RESULT = new NodoDeclaracion(tipoVar.entero, variable, 1);
				:}
		| func_decl:f	{: if(debug) System.out.println("\t regla 14b"); RESULT=f; :}
		;

func_decl  ::= FUNCTION ID:fname LPAREN ID:param RPAREN BEGIN stmt_seq:cuerpo RETURN exp:ret END
				{: if(debug) System.out.println("\t regla 15");
					RESULT = new NodoFuncion(fname, param, cuerpo, ret);
				:}
		;

stmt_seq    ::= stmt_seq:ini SEMI stmt:sent	{: if(debug) System.out.println("\t regla 2a"); 
						NodoBase hijoActual = ini;
						if(hijoActual !=null){
							while(hijoActual.TieneHermano()){
								hijoActual = hijoActual.getHermanoDerecha();
							}
							hijoActual.setHermanoDerecha(sent);
							RESULT=ini;
						}else{
							RESULT=sent;
						}
						:}
            | stmt:sent	{: if(debug) System.out.println("\t regla 2b"); 
				RESULT=sent;				
				:}
		;

stmt        ::= if_stmt:sif	{: if(debug) System.out.println("\t regla 3a"); 
					RESULT=sif;
					:}
            | repeat_stmt:srep	{: if(debug) System.out.println("\t regla 3b");
					RESULT=srep;
					:}
            | assign_stmt:sasi	 {: if(debug) System.out.println("\t regla 3c");
					RESULT=sasi;
					:}
            | read_stmt:slec	{: if(debug) System.out.println("\t regla 3d");
					RESULT=slec;
					:}
            | write_stmt:sesc	{: if(debug) System.out.println("\t regla 3e");
					RESULT=sesc;
					:}
            | for_stmt:sfor	{: if(debug) System.out.println("\t regla 3g");
					RESULT=sfor;
					:}
            | decl_stmt:decl	{: if(debug) System.out.println("\t regla 3h"); RESULT=decl; :}
            | return_stmt:ret	{: if(debug) System.out.println("\t regla 3i"); RESULT=ret; :}
            | error	{: if(debug) System.out.println("\t regla 3f"); 
				System.out.println("Ocurrio error en cup # 0004");
				RESULT=null;
				:}
            ;

decl_stmt  ::= VAR ID:variable SEMI
				{: if(debug) System.out.println("\t regla 18a");
					RESULT = new NodoDeclaracion(tipoVar.entero, variable, 1);
				:}
		| VAR ID:variable COLON ARRAY LBRACKET NUM:size RBRACKET SEMI
				{: if(debug) System.out.println("\t regla 18b");
					RESULT = new NodoDeclaracion(tipoVar.entero, variable, Integer.parseInt(size));
				:}
		;

return_stmt ::= RETURN exp:ex
				{: if(debug) System.out.println("\t regla 19"); RESULT = new NodoReturn(ex); :}
		;

if_stmt     ::= IF exp:ex THEN stmt_seq:pthen END	{: if(debug) System.out.println("\t regla 4a"); 
		RESULT = new NodoIf(ex,pthen);
		:}
		| IF exp:ex THEN stmt_seq:pthen ELSE stmt_seq:pelse END	{: if(debug) System.out.println("\t regla 4b"); 
		RESULT = new NodoIf(ex,pthen,pelse);		
		:}
		;

repeat_stmt ::= REPEAT stmt_seq:cuerpo UNTIL exp:prueba	{: if(debug) System.out.println("\t regla 5"); 
						RESULT = new NodoRepeat(cuerpo,prueba);
						:}
		;

for_stmt    ::= FOR ID:var ASSIGN exp:init TO exp:lim STEP exp:paso stmt_seq:cuerpo END
				{: if(debug) System.out.println("\t regla 16");
					NodoBase ini = new NodoAsignacion(var.toString(), init);
					NodoBase cond = new NodoOperacion(new NodoIdentificador(var.toString()), tipoOp.menorigual, lim);
					NodoBase iter = new NodoAsignacion(var.toString(), new NodoOperacion(new NodoIdentificador(var.toString()), tipoOp.mas, paso));
					RESULT = new NodoFor(ini, cond, iter, cuerpo);
				:}
		;

assign_stmt ::= ID:variable ASSIGN exp:ex	{: if(debug) System.out.println("\t regla 6a");
					if(variable!=null)
					RESULT = new NodoAsignacion(variable.toString(),ex);
					else{
					RESULT = null;
					System.out.println("Ocurrio error en cup # 0001");
					}
					:}
		   | ID:variable LBRACKET exp:desp RBRACKET ASSIGN exp:ex
		   	{: if(debug) System.out.println("\t regla 6b");
        				if(variable!=null)
        				RESULT = new NodoAsignacion(variable.toString(),ex, desp);
        				else{
        				RESULT = null;
        				System.out.println("Ocurrio error en cup # 0001");
        				}
        	:}
		;

read_stmt   ::= READ ID:variable	{: if(debug) System.out.println("\t regla 7a"); 
					System.out.println("Leyendo Variable");
					if(variable!=null)
					RESULT = new NodoLeer(variable.toString());
					else{
					RESULT = null;
					System.out.println("Ocurrio error en cup # 0002");
					}
					:}
		 |  READ ID:variable LBRACKET exp:desp RBRACKET	{: if(debug) System.out.println("\t regla 7b");
        					System.out.println("Leyendo Variable");
        					if(variable!=null)
        					RESULT = new NodoLeer(variable.toString(),desp);
        					else{
        					RESULT = null;
        					System.out.println("Ocurrio error en cup # 0002");
        					}
        					:}
		;

write_stmt  ::= WRITE exp:ex	{: if(debug) System.out.println("\t regla 8"); 
					RESULT= new NodoEscribir(ex);
					:}
		;

exp   ::= logic_exp:exI AND logic_exp:exD
            {: if(debug) System.out.println("\t regla 17a");
            	RESULT = new NodoOperacion(exI,tipoOp.and,exD);
            :}
          | logic_exp:exI OR logic_exp:exD
              {: if(debug) System.out.println("\t regla 17b");
                RESULT = new NodoOperacion(exI,tipoOp.or,exD);
              :}
          | NOT logic_exp:ex
              {: if(debug) System.out.println("\t regla 17c");
                 RESULT = new NodoOperacion(ex,tipoOp.not,new NodoValor(0));
              :}
          | logic_exp:ex
               {: if(debug) System.out.println("\t regla 17d");
                  RESULT = ex;
            :}
       ;

logic_exp   ::= simple_exp:exI LT simple_exp:exD	{: if(debug) System.out.println("\t regla 9a"); 
							RESULT = new NodoOperacion(exI,tipoOp.menor,exD);
							:} 
		| simple_exp:exI EQ simple_exp:exD	{: if(debug) System.out.println("\t regla 9b"); 
							RESULT = new NodoOperacion(exI,tipoOp.igual,exD);
							:}
		| simple_exp:exI GT simple_exp:exD	{: if(debug) System.out.println("\t regla 9d");
        					RESULT = new NodoOperacion(exI,tipoOp.mayor,exD);
        					:}
        | simple_exp:exI LE simple_exp:exD	{: if(debug) System.out.println("\t regla 9e");
        					RESULT = new NodoOperacion(exI,tipoOp.menorigual,exD);
        					:}
        | simple_exp:exI GE simple_exp:exD	{: if(debug) System.out.println("\t regla 9f");
        					RESULT = new NodoOperacion(exI,tipoOp.mayorigual,exD);
        					:}
        | simple_exp:exI NE simple_exp:exD	{: if(debug) System.out.println("\t regla 9g");
        					RESULT = new NodoOperacion(exI,tipoOp.diferente,exD);
        					:}
		| simple_exp:ex	{: if(debug) System.out.println("\t regla 9c"); 
					RESULT = ex;
					:}
		;

simple_exp  ::= simple_exp:exI PLUS term:exD	{: if(debug) System.out.println("\t regla 10a"); 
						RESULT = new NodoOperacion(exI,tipoOp.mas,exD);
						:}
		| simple_exp:exI MINUS term:exD	{: if(debug) System.out.println("\t regla 10b"); 
						RESULT = new NodoOperacion(exI,tipoOp.menos,exD);
						:}
		| term:ex	{: if(debug) System.out.println("\t regla 10c"); 
				RESULT=ex;
				:}
		;

term        ::= term:exI TIMES factor:exD	{: if(debug) System.out.println("\t regla 11a"); 
						RESULT = new NodoOperacion(exI,tipoOp.por,exD);
						:}
		| term:exI OVER factor:exD	{: if(debug) System.out.println("\t regla 11b"); 
						RESULT = new NodoOperacion(exI,tipoOp.entre,exD);
						:}
		| term:exI MOD factor:exD	{: if(debug) System.out.println("\t regla 11d");
        					RESULT = new NodoOperacion(exI,tipoOp.mod,exD);
        					:}
		| term:exI POW factor:exD	{: if(debug) System.out.println("\t regla 11e");
        					RESULT = new NodoOperacion(exI,tipoOp.potencia,exD);
        					:}
		| factor:ex	{: if(debug) System.out.println("\t regla 11c"); 
					RESULT=ex;
					:}
		;

factor      ::= LPAREN exp:ex RPAREN	{: if(debug) System.out.println("\t regla 12a"); 
						RESULT = ex;
						:}
		| NUM:valor	{: if(debug) System.out.println("\t regla 12b"); 
					System.out.println("Devolvi nodo numero entero");
					if(valor!=null){
						RESULT= new NodoValor(Integer.parseInt(valor));
					}else{
						RESULT = null;
						System.out.println("Ocurrio error en cup # 0005");
					}
					:}
		| ID:variable	{: if(debug) System.out.println("\t regla 12c"); 
					if(variable!=null){
						System.out.println("Construyendo Nodo ID para Lexema: "+ variable.toString());
						RESULT= new NodoIdentificador(variable.toString());		
					}else{
						RESULT = null;
						System.out.println("Ocurrio error en cup # 0005");
					}
					:}
		| ID:variable LBRACKET exp:ex RBRACKET	{: if(debug) System.out.println("\t regla 12e");
        					if(variable!=null){
        						System.out.println("Construyendo Nodo ID para Lexema: "+ variable.toString());
        						RESULT= new NodoIdentificador(variable.toString(), ex);
        					}else{
        						RESULT = null;
        						System.out.println("Ocurrio error en cup # 0005");
        					}
        					:}
		| CALL ID:fname LPAREN RPAREN	{: if(debug) System.out.println("\t regla 12f"); RESULT = new NodoLlamada(fname, null); :}
		| CALL ID:fname LPAREN exp:arg RPAREN	{: if(debug) System.out.println("\t regla 12g"); RESULT = new NodoLlamada(fname, arg); :}
		| error	{: if(debug) System.out.println("\t regla 12d"); 
				System.out.println("Ocurrio error en cup # 0003");
				RESULT=null;
				:}
		;